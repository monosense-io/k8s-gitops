# 40 — STORY-DNS-EXTERNALDNS-CF-BIND-TUNNEL — Public/Private DNS via ExternalDNS + Cloudflare Tunnel

Sequence: 40/40 | Prev: STORY-SEC-CERT-MANAGER-ISSUERS.md | Next: —
Sprint: 2 | Lane: Networking & DNS
Global Sequence: 13/41

Status: Draft
Owner: Platform Engineering
Date: 2025-10-22
Links: docs/architecture.md §23; kubernetes/workloads/platform/networking/

## Story
Automate public and private DNS for the platform using two ExternalDNS controllers (Cloudflare + RFC2136/BIND) and terminate public edge traffic through Cloudflare Tunnel (cloudflared). We use split DNS on the same zone `monosense.io`:

- Public resolution (Internet) served by Cloudflare.
- Internal resolution (LAN) served by BIND for the same `monosense.io` zone.

We expose two Gateways and two “anchor” hostnames:
- External anchor: `external.monosense.io` → `<TUNNEL-UUID>.cfargotunnel.com` (proxied in Cloudflare).
- Internal anchor: `internal.monosense.io` → internal Gateway LoadBalancer IP (A/AAAA in BIND).

Application FQDNs (e.g., `app.monosense.io`) CNAME to either `external.monosense.io` or `internal.monosense.io` based on the route’s exposure.

## Why / Outcome
- Zero-origin-exposure on the Internet side via Cloudflare Tunnel.
- Single-source-of-truth: DNS driven from HTTPRoute/Gateway.
- Split-horizon DNS using the same zone (`monosense.io`) with Cloudflare (public) and BIND (internal).

## Scope
- Deploy `cloudflared` (Deployment, config, ExternalSecret, ServiceMonitor) in `networking` namespace.
- Deploy `external-dns-cloudflare` (Gateway source, TXT registry) for `${SECRET_DOMAIN}` (`monosense.io`).
- Deploy `external-dns-rfc2136` (TSIG) for `${SECRET_DOMAIN}` served internally by BIND (same zone, split-horizon).
- RBAC for Gateway API read (httproutes, gateways) and namespaces.
- Prometheus alerts for ExternalDNS staleness and cloudflared readiness.
- Do NOT create manifests outside this story; all changes must be implemented as part of this story’s tasks.

## Acceptance Criteria
1) `cloudflared` Deployment Ready with 2 replicas; metrics and readiness endpoints scrape successfully.
2) External anchor: `external.${SECRET_DOMAIN}` exists in Cloudflare and CNAMEs to `<TUNNEL-UUID>.cfargotunnel.com` with proxied=on.
3) Internal anchor: `internal.${SECRET_DOMAIN}` resolves from the LAN view to the internal Gateway LoadBalancer IP (A/AAAA in BIND).
4) Creating an `HTTPRoute` with annotations publishes `app.${SECRET_DOMAIN}` as a CNAME to the selected anchor (`external.` or `internal.`) within ≤60s (verified in both public and internal resolvers accordingly).
5) TXT registry records present with `txt-owner-id` matching each controller; no cross-controller ownership conflicts; controller-id filtering validated.
6) Alerts: `ExternalDNS*Stale` triggers if no sync within 5 minutes; tunnel disconnect alerts present.

## Dependencies / Inputs
- External Secrets store paths for Cloudflare API token and RFC2136 TSIG secret.
- Gateway API (Cilium Gateway) present per networking stories.
- BIND server reachable from cluster nodes (static IP and zone created) and serving `monosense.io` internally (split-horizon).
- Cloudflare zone `monosense.io` active and managed by platform.
- (Recommended) STORY-OPS-RELOADER-ALL-CLUSTERS installed to enable automatic rollouts on Secret rotation.

## Tasks / Subtasks
- [ ] Cloudflared (external edge)
  - [ ] ExternalSecret → `cloudflared` token/credentials
  - [ ] HelmRelease (2 replicas, QUIC, `/ready`, metrics ServiceMonitor) mounting an external ConfigMap generated by Kustomize (no inline values)
  - [ ] One-time: create `external.${SECRET_DOMAIN}` → `<TUNNEL-UUID>.cfargotunnel.com` (proxied) via `cloudflared tunnel route dns` or API
- [ ] ExternalDNS (Cloudflare – public)
  - [ ] ExternalSecret with `CF_API_TOKEN`, `CF_ZONE_ID`
  - [ ] HelmRelease flags: `--provider=cloudflare`, `--domain-filter=${SECRET_DOMAIN}`, `--cloudflare-proxied`, `--registry=txt`, `--txt-owner-id=k8s-public`, `--txt-prefix=k8s.`, `--source=gateway-httproute`, `--gateway-name=<external-gw-name>`, `--controller-id=public`, `--interval=1m`
  - [ ] RBAC: read `namespaces`, `gateways`, `httproutes`
  - [ ] PrometheusRule for stale syncs
- [ ] ExternalDNS (RFC2136 – internal)
  - [ ] ExternalSecret with TSIG key material (base64), key name, alg
  - [ ] HelmRelease flags: `--provider=rfc2136`, `--rfc2136-host=<bind-ip>`, `--rfc2136-zone=${SECRET_DOMAIN}`, `--domain-filter=${SECRET_DOMAIN}`, `--rfc2136-tsig-secret=<b64>`, `--rfc2136-tsig-keyname=externaldns-key`, `--rfc2136-tsig-secret-alg=hmac-sha256`, `--registry=txt`, `--txt-owner-id=k8s-private`, `--controller-id=private`, `--source=gateway-httproute`, `--gateway-name=<internal-gw-name>`
  - [ ] RBAC: read `namespaces`, `gateways`, `httproutes`
- [ ] Gateways
  - [ ] External Gateway resource named `<external-gw-name>` with listeners for `*.${SECRET_DOMAIN}` and TLS cert `wildcard-tls`
  - [ ] Internal Gateway resource named `<internal-gw-name>` with listeners for `*.${SECRET_DOMAIN}` and TLS cert `wildcard-tls` (LB IP may be pinned via `${CILIUM_GATEWAY_LB_IP_INTERNAL}`)
- [ ] Route Wiring and Controller Targeting
  - [ ] For public routes: HTTPRoute with `external-dns.alpha.kubernetes.io/controller: public`, `external-dns.alpha.kubernetes.io/hostname: app.${SECRET_DOMAIN}`, `external-dns.alpha.kubernetes.io/target: external.${SECRET_DOMAIN}`; attach to `<external-gw-name>`
  - [ ] For internal routes: HTTPRoute with `external-dns.alpha.kubernetes.io/controller: private`, `external-dns.alpha.kubernetes.io/hostname: app.${SECRET_DOMAIN}`, `external-dns.alpha.kubernetes.io/target: internal.${SECRET_DOMAIN}`; attach to `<internal-gw-name>`
- [ ] Observability
  - [ ] ServiceMonitors for ExternalDNS and cloudflared
  - [ ] Alerts for stale sync and tunnel readiness

## Validation Steps
- flux -n flux-system reconcile ks networking --with-source
- kubectl -n networking get deploy,svc,cm,externalsecret
- dig app.${SECRET_DOMAIN} CNAME +short; dig external.${SECRET_DOMAIN} CNAME +short
- curl -Ik https://app.${SECRET_DOMAIN}
- For internal view (LAN resolver): dig app.${SECRET_DOMAIN} CNAME @<bind-ip>; dig internal.${SECRET_DOMAIN} A @<bind-ip>

## Definition of Done
- All ACs met on the target cluster(s); evidence captured in Dev Notes.

---

## Prerequisites (Not Applied Yet)

1) Add `app-template` OCIRepository to Flux repositories per repo rules

- Location: `kubernetes/infrastructure/repositories/oci/app-template.yaml`
- Add to `kubernetes/infrastructure/repositories/oci/kustomization.yaml` resources list

```yaml
apiVersion: source.toolkit.fluxcd.io/v1
kind: OCIRepository
metadata:
  name: app-template
  namespace: flux-system
spec:
  interval: 15m
  layerSelector:
    mediaType: application/vnd.cncf.helm.chart.content.v1.tar+gzip
    operation: copy
  ref:
    tag: 4.3.0
  url: oci://ghcr.io/bjw-s-labs/helm/app-template
```

2) Namespace for networking components (use namespace Component per architecture)

- Consumer sets `namespace: networking` and includes `components/namespace`.
- Do not create standalone Namespace manifests outside the component pattern.

---

## Proposed Manifests (Draft Only; to be committed under kubernetes/workloads/platform/networking/ after approval)

### Directory Layout (proposed)

```
kubernetes/workloads/platform/networking/
  ├─ kustomization.yaml                 # includes cloudflared/ks.yaml, external-dns/*/ks.yaml
  ├─ cloudflared/
  │   ├─ ks.yaml                        # Flux Kustomization targeting ./app
  │   └─ app/
  │       ├─ kustomization.yaml         # uses components/namespace; generates ConfigMap; mounts into HelmRelease
  │       ├─ resources/
  │       │   └─ config.yaml            # cloudflared config
  │       ├─ externalsecret.yaml
  │       └─ helmrelease.yaml
  └─ external-dns/
      ├─ cloudflare/
      │   ├─ ks.yaml
      │   └─ app/ { kustomization.yaml, externalsecret.yaml, rbac.yaml, helmrelease.yaml, prometheusrule.yaml }
      └─ rfc2136/
          ├─ ks.yaml
          └─ app/ { kustomization.yaml, externalsecret.yaml, rbac.yaml, helmrelease.yaml, prometheusrule.yaml }
```

Enablement wiring (after approval): add `- networking` to `kubernetes/workloads/platform/kustomization.yaml` resources; cluster Kustomizations already reconcile `workloads/platform` with postBuild substitution.

The following manifests are provided inline for review. They must be added to the repo only when this story is approved.

### A) cloudflared (Cloudflare Tunnel)

ExternalSecret (1Password → Secret)
```yaml
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: cloudflared
  namespace: networking
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: onepassword
  target:
    name: cloudflared-secret
    template:
      data:
        # Prefer token-based auth. Alternative: credentials.json if org policies require.
        TUNNEL_TOKEN: "{{ .TUNNEL_TOKEN }}"
  dataFrom:
    - extract:
        key: cloudflared
```

Preferred: separate ConfigMap via Kustomize (no inline config in HelmRelease)

cloudflared app kustomization (draft)
```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
namespace: networking
components:
  - ../../../../components/namespace
resources:
  - ./externalsecret.yaml
  - ./helmrelease.yaml
configMapGenerator:
  - name: cloudflared-config
    files:
      - config.yaml=./resources/config.yaml
generatorOptions:
  disableNameSuffixHash: true
```

Example config file (draft)
```yaml
# ./resources/config.yaml
ingress:
  - hostname: "*.${SECRET_DOMAIN}"
    service: https://cilium-gateway.kube-system.svc.cluster.local
    originRequest:
      http2Origin: true
      originServerName: external.${SECRET_DOMAIN}
  - service: http_status:404
```

Note: Confirm the actual external Gateway Service DNS name in your cluster (it may differ based on Cilium Gateway implementation) and update `service:` accordingly before committing.

HelmRelease (app-template) mounting the external ConfigMap
```yaml
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: cloudflared
  namespace: networking
spec:
  chartRef:
    kind: OCIRepository
    name: app-template
    namespace: flux-system
  interval: 1h
  values:
    controllers:
      cloudflared:
        replicas: 2
        strategy: RollingUpdate
        containers:
          app:
            image:
              repository: mirror.gcr.io/cloudflare/cloudflared
              tag: 2025.9.1
            command: ["cloudflared"]
            args: ["tunnel", "run"]
            env:
              NO_AUTOUPDATE: "true"
              TUNNEL_METRICS: "0.0.0.0:8080"
              TUNNEL_POST_QUANTUM: "true"
              TUNNEL_TRANSPORT_PROTOCOL: "quic"
            envFrom:
              - secretRef:
                  name: cloudflared-secret
            probes:
              liveness: &probes
                enabled: true
                custom: true
                spec:
                  httpGet:
                    path: /ready
                    port: &port 8080
                  periodSeconds: 10
                  timeoutSeconds: 1
                  failureThreshold: 3
              readiness: *probes
            resources:
              requests: { cpu: 10m }
              limits: { memory: 128Mi }
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities: { drop: ["ALL"] }
    defaultPodOptions:
      securityContext:
        runAsNonRoot: true
        runAsUser: 568
        runAsGroup: 568
    persistence:
      config:
        type: configMap
        name: cloudflared-config
        globalMounts:
          - path: /etc/cloudflared/config.yaml
            subPath: config.yaml
            readOnly: true
    service:
      app:
        ports:
          http:
            port: *port
    serviceMonitor:
      app:
        endpoints:
          - port: http
```

PrometheusRule (tunnel readiness basic)
```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: cloudflared
  namespace: networking
spec:
  groups:
    - name: cloudflared.rules
      rules:
        - alert: CloudflaredNotReady
          expr: up{job="cloudflared"} == 0
          for: 5m
          annotations:
            summary: cloudflared metrics endpoint is not up
          labels:
            severity: warning
```

One-time DNS anchor (out-of-band)
```text
cloudflared tunnel route dns <TUNNEL-NAME> external.${SECRET_DOMAIN}
```

### B) ExternalDNS — Cloudflare (public)

ExternalSecret
```yaml
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: external-dns-cloudflare
  namespace: networking
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: onepassword
  target:
    name: external-dns-cloudflare-secret
    template:
      data:
        CF_ZONE_ID: "{{ .CLOUDFLARE_ZONE_ID }}"
        CF_API_TOKEN: "{{ .CLOUDFLARE_API_TOKEN }}"
  dataFrom:
    - extract:
        key: cloudflare
```

RBAC
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns-cloudflare
  namespace: networking
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-dns-cloudflare
rules:
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "watch", "list"]
  - apiGroups: ["gateway.networking.k8s.io"]
    resources: ["httproutes", "gateways"]
    verbs: ["get", "watch", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: external-dns-cloudflare
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns-cloudflare
subjects:
  - kind: ServiceAccount
    name: external-dns-cloudflare
    namespace: networking
```

HelmRelease
```yaml
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: external-dns-cloudflare
  namespace: networking
spec:
  chartRef:
    kind: OCIRepository
    name: app-template
    namespace: flux-system
  interval: 1h
  values:
    controllers:
      external-dns-cloudflare:
        containers:
          app:
            image:
              repository: registry.k8s.io/external-dns/external-dns
              tag: v0.19.0
            args:
              - --provider=cloudflare
              - --domain-filter=${SECRET_DOMAIN}
              - --zone-id-filter=$(CF_ZONE_ID)
              - --cloudflare-proxied
              - --registry=txt
              - --txt-owner-id=k8s-public
              - --txt-prefix=k8s.
              - --source=gateway-httproute
              - --gateway-name=cilium-gateway
              - --controller-id=public
              - --interval=1m
              - --log-format=text
              - --log-level=info
            envFrom:
              - secretRef:
                  name: external-dns-cloudflare-secret
            resources:
              requests: { cpu: 10m }
              limits: { memory: 64Mi }
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities: { drop: ["ALL"] }
        serviceAccount:
          name: external-dns-cloudflare
    service:
      app:
        ports:
          http:
            port: 7979
    serviceMonitor:
      app:
        endpoints:
          - port: http
```

PrometheusRule
```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: external-dns-cloudflare
  namespace: networking
spec:
  groups:
    - name: external-dns-cloudflare.rules
      rules:
        - alert: ExternalDNSCloudflareStale
          expr: time() - external_dns_controller_last_sync_timestamp_seconds{job="external-dns-cloudflare"} > 60
          for: 5m
          annotations:
            summary: ExternalDNS (public) has not synced in the last five minutes
          labels:
            severity: critical
```

### C) ExternalDNS — RFC2136 (internal)

ExternalSecret
```yaml
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: external-dns-rfc2136
  namespace: networking
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: onepassword
  target:
    name: external-dns-rfc2136-secret
    template:
      data:
        RFC2136_HOST: "{{ .RFC2136_HOST }}"
        RFC2136_PORT: "{{ .RFC2136_PORT | default "53" }}"
        RFC2136_ZONE: "{{ .RFC2136_ZONE | default "monosense.io" }}"
        RFC2136_TSIG_KEYNAME: "{{ .RFC2136_TSIG_KEYNAME }}"
        RFC2136_TSIG_SECRET: "{{ .RFC2136_TSIG_SECRET_BASE64 }}"
        RFC2136_TSIG_ALG: "{{ .RFC2136_TSIG_ALG | default "hmac-sha256" }}"
  dataFrom:
    - extract:
        key: rfc2136
```

RBAC
```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns-rfc2136
  namespace: networking
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-dns-rfc2136
rules:
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "watch", "list"]
  - apiGroups: ["gateway.networking.k8s.io"]
    resources: ["httproutes", "gateways"]
    verbs: ["get", "watch", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: external-dns-rfc2136
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns-rfc2136
subjects:
  - kind: ServiceAccount
    name: external-dns-rfc2136
    namespace: networking
```

HelmRelease
```yaml
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: external-dns-rfc2136
  namespace: networking
spec:
  chartRef:
    kind: OCIRepository
    name: app-template
    namespace: flux-system
  interval: 1h
  values:
    controllers:
      external-dns-rfc2136:
        containers:
          app:
            image:
              repository: registry.k8s.io/external-dns/external-dns
              tag: v0.19.0
            args:
              - --provider=rfc2136
              - --rfc2136-host=$(RFC2136_HOST)
              - --rfc2136-port=$(RFC2136_PORT)
              - --rfc2136-zone=$(RFC2136_ZONE)
              - --rfc2136-tsig-keyname=$(RFC2136_TSIG_KEYNAME)
              - --rfc2136-tsig-secret=$(RFC2136_TSIG_SECRET)
              - --rfc2136-tsig-secret-alg=$(RFC2136_TSIG_ALG)
              - --rfc2136-tsig-axfr
              - --domain-filter=${SECRET_DOMAIN}
              - --registry=txt
              - --txt-owner-id=k8s-private
              - --source=gateway-httproute
              - --gateway-name=cilium-gateway-internal
              - --controller-id=private
              - --interval=1m
              - --log-format=text
              - --log-level=info
            envFrom:
              - secretRef:
                  name: external-dns-rfc2136-secret
            resources:
              requests: { cpu: 10m }
              limits: { memory: 64Mi }
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities: { drop: ["ALL"] }
        serviceAccount:
          name: external-dns-rfc2136
    service:
      app:
        ports:
          http:
            port: 7979
    serviceMonitor:
      app:
        endpoints:
          - port: http
```

PrometheusRule
```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: external-dns-rfc2136
  namespace: networking
spec:
  groups:
    - name: external-dns-rfc2136.rules
      rules:
        - alert: ExternalDNSRFC2136Stale
          expr: time() - external_dns_controller_last_sync_timestamp_seconds{job="external-dns-rfc2136"} > 60
          for: 5m
          annotations:
            summary: ExternalDNS (internal) has not synced in the last five minutes
          labels:
            severity: critical
```

### D) Stakater Reloader (optional but recommended)

Why: In Buroa’s pattern, many controllers (including cloudflared and external-dns) are annotated with `reloader.stakater.com/auto: "true"` and a cluster‑level Reloader is installed under `kube-system/reloader`. This enables automatic rollouts when ConfigMaps/Secrets change, especially for ExternalSecrets‑managed tokens that otherwise require manual restarts.

Draft manifests:
```yaml
apiVersion: source.toolkit.fluxcd.io/v1
kind: OCIRepository
metadata:
  name: reloader
  namespace: flux-system
spec:
  interval: 15m
  layerSelector:
    mediaType: application/vnd.cncf.helm.chart.content.v1.tar+gzip
    operation: copy
  ref:
    tag: 2.2.3
  url: oci://ghcr.io/stakater/charts/reloader
---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: reloader
  namespace: kube-system
spec:
  chartRef:
    kind: OCIRepository
    name: reloader
    namespace: flux-system
  interval: 1h
  values:
    fullnameOverride: reloader
    reloader:
      readOnlyRootFileSystem: true
      podMonitor:
        enabled: true
        namespace: kube-system
```

Usage in this story (if enabled): add `reloader.stakater.com/auto: "true"` under the corresponding `controllers.<name>.annotations` blocks of cloudflared and both ExternalDNS HelmReleases.

Trade‑off: With this pattern, ConfigMap changes do not change the Pod template by themselves. If Stakater Reloader is installed (see the optional section below), add `reloader.stakater.com/auto: "true"` to `controllers.cloudflared.annotations` to roll on ConfigMap/Secret change. Otherwise, manually rollout pods when the config or secrets change.

### E) Gateways (references)

External (existing)
```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: cilium-gateway
  namespace: kube-system
spec:
  gatewayClassName: cilium
  listeners:
    - name: https
      protocol: HTTPS
      port: 443
      hostname: "*.${SECRET_DOMAIN}"
      tls:
        mode: Terminate
        certificateRefs:
          - kind: Secret
            name: wildcard-tls
            namespace: kube-system
      allowedRoutes:
        namespaces:
          from: All
    - name: http
      protocol: HTTP
      port: 80
      hostname: "*.${SECRET_DOMAIN}"
      allowedRoutes:
        namespaces:
          from: All
```

Internal (proposed — place under `kubernetes/infrastructure/networking/cilium/gateway/gateway-internal.yaml`)
```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: cilium-gateway-internal
  namespace: kube-system
  annotations:
    # io.cilium/lb-ipam-ips: ${CILIUM_GATEWAY_LB_IP_INTERNAL}
spec:
  gatewayClassName: cilium
  listeners:
    - name: https
      protocol: HTTPS
      port: 443
      hostname: "*.${SECRET_DOMAIN}"
      tls:
        mode: Terminate
        certificateRefs:
          - kind: Secret
            name: wildcard-tls
            namespace: kube-system
      allowedRoutes:
        namespaces:
          from: All
    - name: http
      protocol: HTTP
      port: 80
      hostname: "*.${SECRET_DOMAIN}"
      allowedRoutes:
        namespaces:
          from: All
```

### E) Route examples

Public route (CNAME → external)
```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: app-public
  namespace: default
  annotations:
    external-dns.alpha.kubernetes.io/controller: public
    external-dns.alpha.kubernetes.io/hostname: app.${SECRET_DOMAIN}
    external-dns.alpha.kubernetes.io/target: external.${SECRET_DOMAIN}
spec:
  parentRefs:
    - name: cilium-gateway
      namespace: kube-system
  hostnames: ["app.${SECRET_DOMAIN}"]
  rules:
    - backendRefs:
        - name: app-svc
          port: 8080
```

Internal route (CNAME → internal)
```yaml
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: app-internal
  namespace: default
  annotations:
    external-dns.alpha.kubernetes.io/controller: private
    external-dns.alpha.kubernetes.io/hostname: app.${SECRET_DOMAIN}
    external-dns.alpha.kubernetes.io/target: internal.${SECRET_DOMAIN}
spec:
  parentRefs:
    - name: cilium-gateway-internal
      namespace: kube-system
  hostnames: ["app.${SECRET_DOMAIN}"]
  rules:
    - backendRefs:
        - name: app-svc
          port: 8080
```

---

## Enablement (after approval)

1) Commit manifests under:
   - `kubernetes/workloads/platform/networking/cloudflared/app/{externalsecret.yaml,helmrelease.yaml,kustomization.yaml,resources/config.yaml}`
   - `kubernetes/workloads/platform/networking/cloudflared/ks.yaml`
   - `kubernetes/workloads/platform/networking/external-dns/cloudflare/app/{externalsecret.yaml,rbac.yaml,helmrelease.yaml,prometheusrule.yaml,kustomization.yaml}`
   - `kubernetes/workloads/platform/networking/external-dns/cloudflare/ks.yaml`
   - `kubernetes/workloads/platform/networking/external-dns/rfc2136/app/{externalsecret.yaml,rbac.yaml,helmrelease.yaml,prometheusrule.yaml,kustomization.yaml}`
   - `kubernetes/workloads/platform/networking/external-dns/rfc2136/ks.yaml`
   - `kubernetes/workloads/platform/networking/kustomization.yaml` (aggregator includes all ks.yaml above)
   - `kubernetes/infrastructure/networking/cilium/gateway/gateway-internal.yaml`

2) Wire into clusters by adding `- networking` to `kubernetes/workloads/platform/kustomization.yaml` resources. Cluster Kustomizations already reconcile `workloads/platform` for both infra and apps clusters per docs/architecture.md.

3) Add required cluster settings (if desired) to each cluster’s `cluster-settings.yaml`:
   - `CILIUM_GATEWAY_LB_IP_INTERNAL: "10.25.11.122"` (example)
   - Optionally `EXTERNAL_DNS_CLOUDFLARE_ZONE_ID` if you prefer configmap substitution.
