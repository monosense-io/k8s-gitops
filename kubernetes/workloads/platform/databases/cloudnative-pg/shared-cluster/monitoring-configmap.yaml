---
apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-postgres-monitoring
  namespace: cnpg-system
  labels:
    app.kubernetes.io/name: shared-postgres
    app.kubernetes.io/component: monitoring
data:
  custom-queries.yaml: |
    # Database size metrics
    database_size:
      query: |
        SELECT
          datname,
          pg_database_size(datname) as size_bytes
        FROM pg_database
        WHERE datname NOT IN ('template0', 'template1', 'postgres')
      metrics:
        - datname:
            usage: "LABEL"
            description: "Database name"
        - size_bytes:
            usage: "GAUGE"
            description: "Database size in bytes"

    # Table bloat
    table_bloat:
      query: |
        SELECT
          schemaname,
          tablename,
          pg_total_relation_size(schemaname||'.'||tablename) AS size_bytes,
          pg_table_size(schemaname||'.'||tablename) AS table_bytes,
          pg_indexes_size(schemaname||'.'||tablename) AS index_bytes
        FROM pg_tables
        WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
        LIMIT 100
      metrics:
        - schemaname:
            usage: "LABEL"
            description: "Schema name"
        - tablename:
            usage: "LABEL"
            description: "Table name"
        - size_bytes:
            usage: "GAUGE"
            description: "Total relation size in bytes"
        - table_bytes:
            usage: "GAUGE"
            description: "Table size in bytes"
        - index_bytes:
            usage: "GAUGE"
            description: "Index size in bytes"

    # Connection statistics per database
    connections_per_database:
      query: |
        SELECT
          datname,
          count(*) AS connections,
          count(*) FILTER (WHERE state = 'active') AS active_connections,
          count(*) FILTER (WHERE state = 'idle') AS idle_connections,
          count(*) FILTER (WHERE state = 'idle in transaction') AS idle_in_transaction
        FROM pg_stat_activity
        WHERE datname IS NOT NULL
        GROUP BY datname
      metrics:
        - datname:
            usage: "LABEL"
            description: "Database name"
        - connections:
            usage: "GAUGE"
            description: "Total connections"
        - active_connections:
            usage: "GAUGE"
            description: "Active connections"
        - idle_connections:
            usage: "GAUGE"
            description: "Idle connections"
        - idle_in_transaction:
            usage: "GAUGE"
            description: "Idle in transaction connections"

    # Long running queries
    long_running_queries:
      query: |
        SELECT
          datname,
          usename,
          application_name,
          COUNT(*) AS count,
          MAX(EXTRACT(EPOCH FROM (now() - query_start))) AS max_duration_seconds
        FROM pg_stat_activity
        WHERE state = 'active'
          AND query NOT LIKE '%pg_stat_activity%'
          AND query_start < now() - interval '1 minute'
        GROUP BY datname, usename, application_name
      metrics:
        - datname:
            usage: "LABEL"
            description: "Database name"
        - usename:
            usage: "LABEL"
            description: "User name"
        - application_name:
            usage: "LABEL"
            description: "Application name"
        - count:
            usage: "GAUGE"
            description: "Number of long running queries"
        - max_duration_seconds:
            usage: "GAUGE"
            description: "Maximum query duration in seconds"

    # Cache hit ratio per database
    cache_hit_ratio:
      query: |
        SELECT
          datname,
          CASE
            WHEN blks_hit + blks_read = 0 THEN 100
            ELSE round(100.0 * blks_hit / (blks_hit + blks_read), 2)
          END AS cache_hit_ratio
        FROM pg_stat_database
        WHERE datname NOT IN ('template0', 'template1')
      metrics:
        - datname:
            usage: "LABEL"
            description: "Database name"
        - cache_hit_ratio:
            usage: "GAUGE"
            description: "Cache hit ratio percentage"

    # Replication lag
    replication_lag:
      query: |
        SELECT
          application_name,
          client_addr,
          state,
          COALESCE(EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp())), 0) AS lag_seconds,
          pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) AS lag_bytes
        FROM pg_stat_replication
      metrics:
        - application_name:
            usage: "LABEL"
            description: "Application name"
        - client_addr:
            usage: "LABEL"
            description: "Client address"
        - state:
            usage: "LABEL"
            description: "Replication state"
        - lag_seconds:
            usage: "GAUGE"
            description: "Replication lag in seconds"
        - lag_bytes:
            usage: "GAUGE"
            description: "Replication lag in bytes"

    # Vacuum statistics
    vacuum_stats:
      query: |
        SELECT
          schemaname,
          relname,
          EXTRACT(EPOCH FROM (now() - last_vacuum)) AS seconds_since_last_vacuum,
          EXTRACT(EPOCH FROM (now() - last_autovacuum)) AS seconds_since_last_autovacuum,
          n_dead_tup,
          n_live_tup
        FROM pg_stat_user_tables
        WHERE n_dead_tup > 0
        ORDER BY n_dead_tup DESC
        LIMIT 50
      metrics:
        - schemaname:
            usage: "LABEL"
            description: "Schema name"
        - relname:
            usage: "LABEL"
            description: "Relation name"
        - seconds_since_last_vacuum:
            usage: "GAUGE"
            description: "Seconds since last vacuum"
        - seconds_since_last_autovacuum:
            usage: "GAUGE"
            description: "Seconds since last autovacuum"
        - n_dead_tup:
            usage: "GAUGE"
            description: "Number of dead tuples"
        - n_live_tup:
            usage: "GAUGE"
            description: "Number of live tuples"

    # Extension availability monitoring
    extension_status:
      query: |
        SELECT
          extname as extension_name,
          CASE WHEN extversion IS NOT NULL THEN 1 ELSE 0 END as available
        FROM pg_extension
        WHERE extname IN ('pg_trgm', 'btree_gist', 'amcheck', 'pgaudit', 'uuid-ossp')
      metrics:
        - extension_name:
            usage: "LABEL"
            description: "Extension name"
        - available:
            usage: "GAUGE"
            description: "Extension availability (1=available)"

    # Synchronous replication monitoring
    sync_replication_status:
      query: |
        SELECT
          count(*) FILTER (WHERE state = 'streaming' AND sync_state = 'sync') AS sync_replicas,
          count(*) FILTER (WHERE state = 'streaming' AND sync_state = 'async') AS async_replicas
        FROM pg_stat_replication
      metrics:
        - sync_replicas:
            usage: "GAUGE"
            description: "Number of synchronous replicas"
        - async_replicas:
            usage: "GAUGE"
            description: "Number of asynchronous replicas"

    # Pooler connection monitoring
    pooler_connections:
      query: |
        SELECT
          datname,
          usename,
          application_name,
          COUNT(*) AS active_connections,
          SUM(CASE WHEN state = 'active' THEN 1 ELSE 0 END) AS active_queries
        FROM pg_stat_activity
        WHERE application_name LIKE '%bouncer%' OR datname IN ('gitlab', 'registry', 'notary_server', 'notary_signer')
        GROUP BY datname, usename, application_name
      metrics:
        - datname:
            usage: "LABEL"
            description: "Database name"
        - usename:
            usage: "LABEL"
            description: "User name"
        - application_name:
            usage: "LABEL"
            description: "Application name"
        - active_connections:
            usage: "GAUGE"
            description: "Active connections"
        - active_queries:
            usage: "GAUGE"
            description: "Active queries"
